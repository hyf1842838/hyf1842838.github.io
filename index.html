<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  
  

  
  
  <meta name="google-site-verification" content="NCXVSqxqB-os803-VFMtIEd1SUNJVOIjctCfNYUwD0w">
  <meta name="baidu-site-verification" content="Nzwx7HuplM">
  
  <meta name="msvalidate.01" content="9E9EA92F7E5327E1FE8A5196D5253664">
  
  
  
  <title>玄武岩</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="玄武岩">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="玄武岩">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="玄武岩">
  
  
    <link rel="icon" href="http://7u2hdm.com1.z0.glb.clouddn.com/favicon.ico">
  
  <link rel="stylesheet" href="/css/style.css">
  

  
  <!-- baidu webmaster push -->
  <script src="//push.zhanzhang.baidu.com/push.js"></script>
</head></html>
<body class="home blog custom-background custom-font-enabled single-author">
  <div id="page" class="hfeed site">
      <header id="masthead" class="site-header" role="banner">
    <hgroup>
      <h1 class="site-title">
        <a href="/" title="玄武岩" rel="home">玄武岩</a>
      </h1>
      
        <script type="text/javascript" src="http://api.hitokoto.us/rand?encode=js&charset=utf-8"></script>
        <h2 class="site-description"><script>hitokoto();</script></h2>
      
    </hgroup>

    <nav id="site-navigation" class="main-navigation" role="navigation">
            <button class="menu-toggle">菜单</button>
            <a class="assistive-text" href="/#content" title="跳至内容">跳至内容</a><!--TODO-->
            <div class="menu-main-container">
                <ul id="menu-main" class="nav-menu">
                
                    <li class="menu-item menu-item-type-post_type menu-item-object-page"><a href="http://it-ebooks.flygon.net/">电子书</a></li>
                
                    <li class="menu-item menu-item-type-post_type menu-item-object-page"><a href="/makes">MAKES</a></li>
                
                    <li class="menu-item menu-item-type-post_type menu-item-object-page"><a href="/about">关于我</a></li>
                
                    <li class="menu-item menu-item-type-post_type menu-item-object-page"><a href="/atom.xml">RSS</a></li>
                
                    <li class="menu-item menu-item-type-post_type menu-item-object-page"><a href="https://github.com/hyf1842838/blog">fork me on github</a></li>
                
                </ul>
            </div>
    </nav>
</header>
      <div id="main" class="wrapper">
        <div id="primary" class="site-content"><div id="content" role="main">
  
    <article id="post-中间件、分页及文件上传" class="post-中间件、分页及文件上传 post type-post status-publish format-standard hentry">
    <!---->

      <header class="entry-header">
        
        
  
    <h1 class="entry-title">
      <a class="article-title" href="/2019/01/09/中间件、分页及文件上传/">中间件、分页及文件上传</a>
    </h1>
  

        
        <div class="comments-link">
            
            <a href="javascript:void(0);" data-url="http://yoursite.com/2019/01/09/中间件、分页及文件上传/" data-id="cjqpf0mcg0006msuruo54exdz" class="leave-reply bdsharebuttonbox" data-cmd="more">分享</a>
        </div><!-- .comments-link -->
      </header><!-- .entry-header -->

    <div class="entry-content">
      
        <h2 id="1装饰器-闭包"><a href="#1装饰器-闭包" class="headerlink" title="1装饰器(闭包)"></a>1装饰器(闭包)</h2><p>装饰器三特征<br>1.外层函数内嵌内层函数<br>2.外层函数返回内层函数<br>3.内层函数调用外层函数的参数<br>不用装饰器时的hindex方法</p>
<pre><code>def hindex(request):
if request.method == &apos;GET&apos;:
    if request.session.get(&apos;user_id&apos;): #判断user_id存在不
        user_id = request.session[&apos;user_id&apos;]
        user = User.objects.get(pk=user_id)
        print(&apos;当前登陆系统的人为:%s&apos; % user.username)
        return render(request, &apos;index.html&apos;)
else:
    return render(request, &apos;login.html&apos;)
</code></pre><p>用装饰器实现上述方法</p>
<pre><code>def is_login(func):
def check_status(request):
    if request.session.get(&apos;user_id&apos;):
        return func(request) #相当于my_index函数
    else:
        return HttpResponseRedirect(reverse(&apos;user:login&apos;))
return check_status

装饰器实现hindex函数的方法
@is_login
def my_hindex(request):
    if request.method == &apos;GET&apos;:
        return render(request, &apos;index.html&apos;)
</code></pre><h2 id="2中间件"><a href="#2中间件" class="headerlink" title="2中间件"></a>2中间件</h2><h3 id="2-1中间件基本概念"><a href="#2-1中间件基本概念" class="headerlink" title="2.1中间件基本概念"></a>2.1中间件基本概念</h3><p>中间件的作用就是：面向切面编程AOP，在httpRequest请求还没到的view之前，与view返回的httpResponse还未发送给请求者之前，对httpRequest与httpResponse做出修改。<br>Django的setting文件中有一个MIDDLEWARE_CLASSES列表专门放置中间件；只要把中间件放入MIDDLEWARE_CLASSES中就可以使用。<br>中间件有process_request(用户发起访问请求到匹配路由之间)、process_view(匹配路由到业务之间)、process_template_response(业务到html模板之间)、process_exception(异常捕获：业务到模型至模板之间)及process_response(模板到用户看到的渲染页面之间)五种；<br>其中process_request、process_view及process_response三种经常用到；<br>五个中间件函数：<br>1.process_request(self,request):在匹配路由之前被调用；<br>在process_request不要写return http对象（否则其他中间件不再被执行），但可以写return None表示不在执行本中间件以下内容，直接跳出process_request方法<br>2.process_view(self,request,view_func,view_args,view_kwargs):在执行视图函数之前被调用<br>3.process_response(self,request,response):在视图函数响应之后被调用<br>4.process_template_response():默认不会被主动调用<br>5.process_exception():默认不会被主动调用，当出现异常时，才会被触发<br>中间件执行顺序，先执行process_request，再执行视图函数(views)，最后执行process_response<br> 有多个中间件的时候的执行顺序，先按定义顺序将所有process_request执行完，再执行视图函数(views)，最后逆序执行所有process_response<br>执行process_request从上到下执行，执行process_view从上到下执行；剩下三个都是从下到上执行<br>process_request函数中不能写return内容，写了将会在此结束只执行process_request和process_response</p>
<h3 id="2-2中间件函数的基本参数及示例"><a href="#2-2中间件函数的基本参数及示例" class="headerlink" title="2.2中间件函数的基本参数及示例"></a>2.2中间件函数的基本参数及示例</h3><pre><code>from user.models import User
class TestMiddlware1(MiddlewareMixin):
    def process_request(self, request):
        print(&apos;test1 process request&apos;)
         对所有的请求都进行登陆状态的校验
        path = request.path
        if path in [&apos;/user/register/&apos;, &apos;/user/login/&apos;, &apos;/user/my_login/&apos;]:
             跳过以下所有代码，直接访问路由对应的视图函数
            return None
        try:
            user_id = request.session[&apos;user_id&apos;]
            user = User.objects.get(pk=user_id)
            request.user = user
            return None
        except Exception as e:
            return HttpResponseRedirect(reverse(&apos;user:my_login&apos;))

def process_view(self, request, view_func, view_args, view_kwargs):
    print(&apos;test1 view&apos;)
def process_response(self, request, response):
    print(&apos;test1 process response&apos;)
    return response

class TestMiddlware2(MiddlewareMixin):
    def process_request(self, request):
        print(&apos;test2 process request&apos;)
    def process_view(self, request, view_func, view_args, view_kwargs):
        print(&apos;test2 view&apos;)
    def process_response(self, request, response):
        print(&apos;test2 process response&apos;)
        return response
    #test1 process request、test2 process request、test1 view
    #test2 view、test2 process response、test1 process response
</code></pre><h2 id="3分页"><a href="#3分页" class="headerlink" title="3分页"></a>3分页</h2><p>分页可以有两种方法；切片和用paginator库<br>切片主要是先查询出要查看的内容的所有信息，然后对信息进行按要查看的页进行切片</p>
<h3 id="3-1切片分页"><a href="#3-1切片分页" class="headerlink" title="3.1切片分页"></a>3.1切片分页</h3><p>page = int(request.GET.get(‘page’, 1))；获取要查看的页码<br>stus = Student.objects.all()[((page-1)<em>3):(page</em>3)]；获得要查看的页的信息</p>
<pre><code>def all_stu(request):
if request.method == &apos;GET&apos;:
    获取分页的角码
    pag = int(request.GET.get(&apos;page&apos;, 1))
    第一种方式：使用切片实现分页
    stus = Student.objects.all()[((pag-1)*3):(pag*3)]
    return render(request, &apos;stus.html&apos;, {&apos;stus&apos;: stus})
</code></pre><h3 id="3-2paginator库分页"><a href="#3-2paginator库分页" class="headerlink" title="3.2paginator库分页"></a>3.2paginator库分页</h3><p>pg=Paginator(总数据，一页显示信息数)<br>取某一页信息:pg.page(某页)<br>page_range:页码<br>has_previous:是否有上一页<br>has_next：是否有下一页<br>previous_page_number:上一页的页码<br>paginator.page(所获取具体某页的页数)<br>stus.has_previous 判断stus中当前页面是否存在上一页，返回布尔值<br>stus.has_next 判断stus中当前页面是否存在下一页，返回布尔值<br>stus.previous_page_number获取stus中当前页面中的上一页的页码，返回int值<br>stus.number：获取当前页页码<br>stus.paginator.num_pages：获取共多少页</p>
<pre><code>def all_stu(request):
if request.method == &apos;GET&apos;:
    获取分页的角码
    pag = int(request.GET.get(&apos;page&apos;, 1))
    第二种方式：使用Paginator库实现分页
    stus = Student.objects.all()
    pg = Paginator(stus, 3)
    my_stu = pg.page(pag)
    return render(request, &apos;stus.html&apos;, {&apos;stus&apos;: my_stu})
</code></pre><p>html中代码<br>在html文件中跳转至另一个路由：/app/add_stu/</p>
<pre><code>&lt;a href=&quot;{% url 'app:add_stu' %}&quot;&gt;添加学生信息&lt;/a&gt;

{% extends 'base_main.html' %}
{% block content %}
        <p><a href="{% url 'app:add_stu' %}">添加学生信息</a></p>
        <table>
            <thead>
                <th>编号:</th>
                <th>姓名:</th>
                <th>年龄:</th>
                <th>性别:</th>
                <th>头像:</th>
            </thead>
            <tbody>
                {% for stu in stus %}
                    <tr>
                    <td>{{ forloop.counter }}</td>
                    <td>{{ stu.s_name }}</td>
                    <td>{{ stu.s_age }}</td>
                    <td>{% if stu.s_gender %}
                            男
                        {% else %}
                            女
                        {% endif %}
                    </td>
                    <td><img src="/media/{{ stu.icon }}"></td>
                    </tr>
                {% endfor %}
            </tbody>
        </table>
        <p>
            当前第{{ stus.number }}页，共{{ stus.paginator.num_pages }}页
    
            {% if stus.has_previous %}
                <a href="{% url 'app:all_stu' %}?page={{ stus.previous_page_number }}">上一页</a>
            {% endif %}
            {#        分页并标记页码进行跳转#}
            {% for i in stus.paginator.page_range %}
    {#            <a href="/app/all_stu/?page={{ i }}">{{ i }}</a>#}
                <a href="{% url 'app:all_stu' %}?page={{ i }}">{{ i }}</a>
            {% endfor %}
            {% if stus.has_next %}
                <a href="{% url 'app:all_stu' %}?page={{ stus.next_page_number }}">下一页</a>
            {% endif %}
        </p>
        {% for stu in stus %}
        {% endfor %}
    {% endblock %}
</code></pre><h2 id="4文件上传"><a href="#4文件上传" class="headerlink" title="4文件上传"></a>4文件上传</h2><p>文件上传需要先安装Pillow（执行pip install Pillow）<br>文件上传中，需要在前端的form表单中添加enctype=”multipart/form-data”参数<br>后端获取上传的图片等文件：request.FILES.get(key)或requests.FILES[‘key’]<br>在模型中新加字段：ImageField(upload_to=’upload’)<br>模板中解析:&lt;img src=’/media/‘</p>
<h3 id="4-1文件上传的配置"><a href="#4-1文件上传的配置" class="headerlink" title="4.1文件上传的配置"></a>4.1文件上传的配置</h3><p>settings中最后配置访问media目录<br>MEDIA_URL = ‘/media/‘<br>MEDIA_ROOT = os.path.join(BASE_DIR, ‘media’)<br>django工程文件下路由文件中的最后配置<br>from django.contrib.staticfiles.urls import static<br>urlpatterns += static(MEDIA_URL, document_root=MEDIA_ROOT)<br>​<br>    class Student(models.Model):<br>        icon = models.ImageField(upload_to=’upload’, null=True)<br>添加了新的字段后，不要再次迁移，而是到数据库的查询文件中新添加一列</p>
<pre><code>alter table student add icon varchar(100) null;数据库中给表添加一列
</code></pre><p>输入姓名和上传图片</p>
<pre><code>{% extends 'base_main.html' %}
{% block content %}
        <form action="" method="post" enctype="multipart/form-data">
            <p>姓名:<input type="text" name="username"></p>
            <p>图片:<input type="file" name="icon"></p>
            <p><input type="submit" value="提交"></p>
        </form>
    {% endblock %}
</code></pre><p>新建用户保存上传文件及姓名</p>
<pre><code>def add_stu(request):
    if request.method == &apos;GET&apos;:
        return render(request, &apos;add_stu.html&apos;)
    if request.method == &apos;POST&apos;:
        # 1.获取数据
        username = request.POST.get(&apos;username&apos;)
        icon = request.FILES.get(&apos;icon&apos;)
        # 2. 保存
        Student.objects.create(s_name=username, icon=icon)
        # 3. 跳转到列表页面
        return HttpResponseRedirect(reverse(&apos;app:all_stu&apos;))
</code></pre><p>查看文件代码见3.2代码块中</p>

      
    </div><!-- .entry-content -->

    <footer class="entry-meta">
    <a href="/2019/01/09/中间件、分页及文件上传/">
    <time datetime="2019-01-09T15:53:25.000Z" class="entry-date">
        2019-01-09
    </time>
</a>
    
    
    </footer>
</article>






  
    <article id="post-cookie及session" class="post-cookie及session post type-post status-publish format-standard hentry">
    <!---->

      <header class="entry-header">
        
        
  
    <h1 class="entry-title">
      <a class="article-title" href="/2019/01/08/cookie及session/">cookie及session</a>
    </h1>
  

        
        <div class="comments-link">
            
            <a href="javascript:void(0);" data-url="http://yoursite.com/2019/01/08/cookie及session/" data-id="cjqpf0mbx0004msurfvpdho25" class="leave-reply bdsharebuttonbox" data-cmd="more">分享</a>
        </div><!-- .comments-link -->
      </header><!-- .entry-header -->

    <div class="entry-content">
      
        <h2 id="1请求方式"><a href="#1请求方式" class="headerlink" title="1请求方式"></a>1请求方式</h2><p>请求方式有get和post两种方式；<br>数据查询用get请求<br>数据操作（增、删及改操作）用post请求</p>
<h2 id="1-1参数类型"><a href="#1-1参数类型" class="headerlink" title="1.1参数类型"></a>1.1参数类型</h2><p>传参GET：获取get请求传递的参数（request.GET[‘key’]/request.GET.get(‘key’)）<br>传参POST：获取post请求传递的参数（request.POST[‘key’]/request.POST.get(‘key’)）<br>传参FILES：获取上传的文件、图片等内容（request.FILES[‘key’]/request.FILES.get(‘key’)）<br>路径path：获取当前请求的路径（request.path）<br>COOKIES：存储网站的一些基本信息：如登陆的信息（request.COOKIES[‘key’]/request.COOKIES.get(‘key’)）<br>COOKIES存储的内容是存储在客户端（浏览器）</p>
<h2 id="2响应response"><a href="#2响应response" class="headerlink" title="2响应response"></a>2响应response</h2><p>HttpResponse：响应字符串<br>JsonResponse：响应json，用于ajax异步请求<br>render：响应页面<br>HttpResponseRedirect：跳转<br>  第一种，硬编码跳转：HttpResponseRedirect(‘/app/index/1/‘)<br>  第二种,重命名跳转：HttpResponseRedirect(reverse(‘user:login’))</p>
<pre><code>{% block content %}
        <form action="" method="post">
            <p>姓名:<input type="text" name="username"></p>
            <p>密码:<input type="text" name="password"></p>
            <p><input type="submit" value="提交"></p>
        </form>
    {% endblock %}
</code></pre><p>action中写地址就提交到写的地址，如果不写，就提交到当前地址。<br>在测试时，先注释settings中的47行，获取权限。</p>
<h3 id="2-1给路由重命名"><a href="#2-1给路由重命名" class="headerlink" title="2.1给路由重命名"></a>2.1给路由重命名</h3><pre><code>给工程下的app路由重命名
path(&apos;app/&apos;, include((&apos;app.urls&apos;, &apos;app&apos;), namespace=&apos;new_name&apos;)),
path(&apos;user/&apos;, include((&apos;user.urls&apos;, &apos;user&apos;), namespace=&apos;user&apos;))

给应用下的路由重命名
path(&apos;hindex/&lt;int:id&gt;/&apos;, views.hindex, name=&apos;new_index&apos;),


def hindex(request):
    if request.method == &apos;GET&apos;:
        return HttpResponseRedirect(reverse(&apos;new_name:new_index&apos;, kwargs={&apos;id&apos;: 2})) #响应跳转
    elif request.method == &apos;POST&apos;:
        pass
</code></pre><h2 id="3登陆"><a href="#3登陆" class="headerlink" title="3登陆"></a>3登陆</h2><h3 id="3-1render和redirect的区别"><a href="#3-1render和redirect的区别" class="headerlink" title="3.1render和redirect的区别"></a>3.1render和redirect的区别</h3><p>render是将变量渲染到当前页面中；<br>而redirect是HTTP中的1个跳转的函数,一般会生成302状态码，是直接跳转到一个新的页面</p>
<pre><code>return render(request, &apos;login.html&apos;)
return HttpResponseRedirect(reverse(&apos;user:login&apos;))
</code></pre><h3 id="3-2登陆"><a href="#3-2登陆" class="headerlink" title="3.2登陆"></a>3.2登陆</h3><p>res.set_cookie(‘token’, token, max_age=30)将变量token的值作为值赋给键token，生成一个存在时间为30秒的cookie<br>check_password(password,user.password),返回布尔值;用输入的密码跟数据库存储的密码进行比较是否相同<br>password = make_password(password) 对密码进行加密转成暗码（注册生效存入数据库时使用）<br> random.choice(s) 从变量s中随机取一个字符<br>获取登陆提交的参数：<br>username = request.POST.get(‘username’)<br>password = request.POST.get(‘password’)<br>cookie：产生背景：由于http无状态协议，导致后端无法知道当前发送请求的人是谁，用于存储一些不是很重要的内容；<br>存储：set_cookie(key,value,max_age/expris(存储时间秒/存储到的日期))<br>删除：delete_cookie(key)</p>
<pre><code>def login(request):
    if request.method == &apos;GET&apos;:
        return render(request, &apos;login.html&apos;)
    if request.method == &apos;POST&apos;:
         获取登陆提交的参数
        username = request.POST.get(&apos;username&apos;)
        password = request.POST.get(&apos;password&apos;)
        user = User.objects.filter(username=username).first()
        校验密码          
        if check_password(password, user.password):
             模拟登陆成功，跳转至指定页面
            res = HttpResponseRedirect(reverse(&apos;user:index&apos;))
            设置cookie
            s = &apos;0123456789abcdefg&apos;
            token = &apos;&apos;
            for i in range(20):
                token += random.choice(s) #从s中随机取字符生成cookie
            res.set_cookie(&apos;token&apos;, token, max_age=30)
            删除之前的cookie
            UserToken.objects.filter(user_id=user.id).delete()
            保存新的token到user_token表中
            UserToken.objects.create(user_id=user.id, token=token)
            return res
        else:
            登陆失败
            return HttpResponseRedirect(reverse(&apos;user:login&apos;))
</code></pre><h2 id="4主页"><a href="#4主页" class="headerlink" title="4主页"></a>4主页</h2><p>从cookies中获取登陆校验的token值<br>token = request.COOKIES.get(‘token’)</p>
<pre><code>def index(request):
    if request.method == &apos;GET&apos;:
        从cookies中获取登陆校验的token值
        token = request.COOKIES.get(&apos;token&apos;)
        判断token是否存在，如果不存在说明没有登陆或登陆失效
        if not token:
            return HttpResponseRedirect(reverse(&apos;user:login&apos;))
        user_token = UserToken.objects.filter(token=token).first()
        判断user_token表中是否存在token值，如果不存在，表示用户没有登陆
        if not user_token:
            return HttpResponseRedirect(reverse(&apos;user:login&apos;))
        else:
            return render(request, &apos;index.html&apos;)
</code></pre><h2 id="5退出"><a href="#5退出" class="headerlink" title="5退出"></a>5退出</h2><p>删除cookie中的键值对：res.delete_cookie(‘token’)</p>
<pre><code>def logout(request):
    if request.method == &apos;GET&apos;:
       注销(删除cookie中的键值对)
        res = HttpResponseRedirect(reverse(&apos;user:login&apos;))
        res.delete_cookie(&apos;token&apos;)
        return res
</code></pre><h2 id="6注册"><a href="#6注册" class="headerlink" title="6注册"></a>6注册</h2><pre><code>def register(request):
    if request.method == &apos;GET&apos;:
        return render(request, &apos;register.html&apos;)
    if request.method == &apos;POST&apos;:
        1.接收页面中传递的参数
        username = request.POST.get(&apos;username&apos;)
        password = request.POST.get(&apos;password&apos;)
        password2 = request.POST.get(&apos;password2&apos;)
        2.实现保存用户信息到user表中
        if User.objects.filter(username=username).exists():
            msg = &apos;账号已存在&apos;
            return render(request, &apos;register.html&apos;, {&apos;msg&apos;: msg})
        elif password != password2:
            msg = &apos;密码不一致&apos;
            return render(request, &apos;register.html&apos;, {&apos;msg&apos;: msg})
        3注册
        else:
            password = make_password(password) # 对密码进行加密
            User.objects.create(username=username, password=password)
            4跳转到登陆
            return HttpResponseRedirect(reverse(&apos;user:login&apos;))
            # return render(request, &apos;login.html&apos;)
</code></pre><h2 id="7用session实现登陆操作"><a href="#7用session实现登陆操作" class="headerlink" title="7用session实现登陆操作"></a>7用session实现登陆操作</h2><h3 id="7-1session作用"><a href="#7-1session作用" class="headerlink" title="7.1session作用"></a>7.1session作用</h3><p>1.向cookie中保存键值对，键为sessionid(存在浏览器中)<br>2.向django_session表中保存sessionid值(保存在session_data中)<br>3.向django_session表中存键值对{‘username’:coco}</p>
<h3 id="7-2session用法"><a href="#7-2session用法" class="headerlink" title="7.2session用法"></a>7.2session用法</h3><p>产生背景，由于cookie中存储空间有限，很容易被截取，因此cookie存重要内容不安全，需要使用session进行数据存储<br>向session中存数据:request.session[key]=value<br>从session中取数据:request.session[‘key’]或request.session.get(‘key’)<br>删除cookie和session中的所有信息：request.session.flush()（推荐）<br>删除user_id中的键值对:del request.session[‘user_id’]</p>
<pre><code>def my_login(request):
    if request.method == &apos;GET&apos;:
        return render(request, &apos;login.html&apos;)
    if request.method == &apos;POST&apos;:
        username = request.POST.get(&apos;username&apos;)
        password = request.POST.get(&apos;password&apos;)
        user = User.objects.filter(username=username).first()
        if check_password(password, user.password):
            向session中存数据，将user.id保存在user_id键中
            request.session[&apos;user_id&apos;] = user.id
            return HttpResponseRedirect(reverse(&apos;user:hindex&apos;))
        else:
            msg = &apos;账号或者密码错误&apos;
            return render(request, &apos;login.html&apos;, {&apos;msg&apos;: msg})
</code></pre><h2 id="8用session获取当前登陆用户信息"><a href="#8用session获取当前登陆用户信息" class="headerlink" title="8用session获取当前登陆用户信息"></a>8用session获取当前登陆用户信息</h2><pre><code>def hindex(request):
    if request.method == &apos;GET&apos;:
        if request.session.get(&apos;user_id&apos;): #判断user_id存在不
            从session中取数据
            user_id = request.session[&apos;user_id&apos;]
            user = User.objects.get(pk=user_id)
            print(&apos;当前登陆系统的人为:%s&apos; % user.username)
            return render(request, &apos;index.html&apos;)
    else:
        return render(request, &apos;login.html&apos;)
</code></pre><h2 id="9用session退出"><a href="#9用session退出" class="headerlink" title="9用session退出"></a>9用session退出</h2><p>退出登陆可以用以下方法实现<br>删除cookie中的sessionid值<br>删除django_session表中的数据<br>删除django_session表中的session_data中的user_id<br>以上三种方法都可以实现退出操作</p>
<pre><code>def my_logout(request):
    if request.method == &apos;GET&apos;:
        request.session.flush()
        # del request.session[&apos;user_id&apos;]
        return HttpResponseRedirect(reverse(&apos;user:my_login&apos;))
</code></pre>
      
    </div><!-- .entry-content -->

    <footer class="entry-meta">
    <a href="/2019/01/08/cookie及session/">
    <time datetime="2019-01-08T11:32:25.000Z" class="entry-date">
        2019-01-08
    </time>
</a>
    
    
    </footer>
</article>






  
    <article id="post-模板设计" class="post-模板设计 post type-post status-publish format-standard hentry">
    <!---->

      <header class="entry-header">
        
        
  
    <h1 class="entry-title">
      <a class="article-title" href="/2019/01/07/模板设计/">模板设计</a>
    </h1>
  

        
        <div class="comments-link">
            
            <a href="javascript:void(0);" data-url="http://yoursite.com/2019/01/07/模板设计/" data-id="cjqpf0mb60003msurjo2d7o2v" class="leave-reply bdsharebuttonbox" data-cmd="more">分享</a>
        </div><!-- .comments-link -->
      </header><!-- .entry-header -->

    <div class="entry-content">
      
        <h2 id="1引入静态文件"><a href="#1引入静态文件" class="headerlink" title="1引入静态文件"></a>1引入静态文件</h2><p>在settings中对最后的STATIC_URL进行如下设置</p>
<pre><code>STATIC_URL = &apos;/static/&apos;
STATICFILES_DIRS = [
    os.path.join(BASE_DIR, &apos;static&apos;)
]
</code></pre><p>在新建的html文件中导入设置的样式表的方法有三种；<br>方法一</p>
<pre><code>&lt;link rel=&quot;stylesheet&quot; href=&quot;../static/css/style.css&quot;&gt;
</code></pre><p>方法二（推荐）：</p>
<pre><code>&lt;link rel=&quot;stylesheet&quot; href=&quot;/static/css/style.css&quot;&gt;
</code></pre><p>方法三：</p>
<pre><code>{% load static %}
&lt;link rel=&quot;stylesheet&quot; href=&quot;{% static 'css/style.css' %}&quot;&gt;
</code></pre><h2 id="2标签"><a href="#2标签" class="headerlink" title="2标签"></a>2标签</h2><h3 id="2-1if标签"><a href="#2-1if标签" class="headerlink" title="2.1if标签"></a>2.1if标签</h3><pre><code>{% if name %}
        {{ name }}
    {% else %}
        name为空
    {% endif %}
</code></pre><h3 id="2-2for标签"><a href="#2-2for标签" class="headerlink" title="2.2for标签"></a>2.2for标签</h3><pre><code>{% for i in a %}
        i
    {% empty %}
        a变量为空
    {% endfor %}
</code></pre><h3 id="2-3forloop变量"><a href="#2-3forloop变量" class="headerlink" title="2.3forloop变量"></a>2.3forloop变量</h3><p>if和for中自带变量forloop，用于统计for循环循环的次数<br>判断循环最后一次：,返回布尔值<br>判断循环第一次：,返回布尔值<br>ifequal:判断两个值是否相等<br>从0开始统计，不加0就从1开始<br>倒序以0结束<br>{\% ifequal forloop.counter 3 %}判断是否等于3</p>
<pre><code>{% for i in a %}
        `<p 2="" {%="" if="" forloop.counter="=" %}="" style="font-weight: bold;" endif="">`
        `</p><p {%="" if="" forloop.first="" %}="" style="font-weight:bold;" endif="">`
        `</p><p 3="" {%="" ifequal="" forloop.counter="" %}="" style="font-weight:bold;" endifequal="">
            `编号:{{ forloop.counter0 }}  成绩:{{ i }}`
        </p>`
    {% empty %}
        a变量为空
    {% endfor %}
</code></pre><h3 id="2-4注解"><a href="#2-4注解" class="headerlink" title="2.4注解"></a>2.4注解</h3><p>web形式注解:&lt;！–注解内容–&gt;，需注意不能定义错误的标签语法<br>django框架中的注解 单行注解;{\% comment %}注解内容{\% endcomment %} 多行注解</p>
<h2 id="3过滤器"><a href="#3过滤器" class="headerlink" title="3过滤器"></a>3过滤器</h2><pre><code>将内容进行渲染再展示{{ a | 过滤器 }}
</code></pre><p>safe:解析变量中的样式<br>default:默认值<br>upper:/lower:变量大小写的转换<br>capfirst:首字母大写<br>random:随机取字符<br>first/last:取出变量中的首/尾元素<br>length:计算变量的长度<br>add:变量的加减</p>
<pre><code>&lt;p&gt;{{ b | safe }}&lt;/p&gt;
&lt;!--全部转大写--&gt;
&lt;p&gt;{{ 'python' | upper }}&lt;/p&gt;
&lt;!--全部转小写--&gt;
&lt;p&gt;{{ 'PYthOn' | lower }}&lt;/p&gt;
&lt;!--内容加1--&gt;
&lt;p&gt;{{ 4 | add:'1' }}&lt;/p&gt;
&lt;!--内容减1--&gt;
&lt;p&gt;{{ 4 | add:'-1' }}&lt;/p&gt;
&lt;!--首字母大写--&gt;
&lt;p&gt;{{ 'python' | capfirst }}&lt;/p&gt;
&lt;!--空默认为无--&gt;
&lt;p&gt;{{ '' | default:'无' }}&lt;/p&gt;
&lt;!--解析第一个字符--&gt;
&lt;p&gt;{{ 'python' | first }}&lt;/p&gt;
&lt;!--解析最后一个字符--&gt;
&lt;p&gt;{{ 'python' | last }}&lt;/p&gt;
&lt;!--随机取一个字符--&gt;
&lt;p&gt;{{ 'python' | random }}&lt;/p&gt;
</code></pre><h2 id="4继承"><a href="#4继承" class="headerlink" title="4继承"></a>4继承</h2><p>父模板：定义好可以被子模板动态填充内容的block块<br>子模板：继承于父模板，并实现填充block块的内容<br>定义block块的名字不能重复<br>继承:{\% extends ‘父模板’ %}<br>动态填充block块的内容:{\% block 名称 %}{\% endblock %}<br>获取父模板中块之前定义好的内容:</p>
<pre><code>&lt;!--定义模板--&gt;
&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;Title&lt;/title&gt;
    {% block js %}
        {% endblock %}
&lt;/head&gt;
&lt;body&gt;
    {% block content %}
        {% endblock %}
&lt;/body&gt;
&lt;/html&gt;
&lt;!--子模板继承父模板内容--&gt;
{% extends 'base.html' %}
{% block js %}
        <script src="https://code.jquery.com/jquery-3.0.0.min.js"></script>
    {% endblock %}
</code></pre><h2 id="5路由urls"><a href="#5路由urls" class="headerlink" title="5路由urls"></a>5路由urls</h2><h3 id="5-1配置路由分发"><a href="#5-1配置路由分发" class="headerlink" title="5.1配置路由分发"></a>5.1配置路由分发</h3><p>django项目中urls.py文件中配置<br>path(‘app/‘,include(‘app.urls’)), 新版本django<br>path(‘app/‘,include(‘app.urls’, ‘app’)) 老版本django</p>
<h3 id="5-2接收参数"><a href="#5-2接收参数" class="headerlink" title="5.2接收参数"></a>5.2接收参数</h3><p>每个应用下对应的urls.py文件中配置</p>
<pre><code>urlpatterns = [
    re_path(&apos;index/(\d+)/&apos;, views.index), #路由匹配的值为int类型
    path(&apos;index/&lt;int:id&gt;/&apos;, views.index), #路由匹配的值为int类型
    path(&apos;name/&lt;str:name&gt;/&apos;, views.get_name), #路由匹配的值为字符类型
    path(&apos;get_uuid/&apos;, views.get_uuid), #路由匹配的值为uuid类型
    path(&apos;g_uuid/&lt;uuid:uid&gt;/&apos;, views.g_uuid),
    path(&apos;path/&lt;path:phth&gt;/&apos;, views.get_path), #路由匹配的值为path类型
    # 接收多个参数
    path(&apos;params/&lt;int:year&gt;/&lt;int:month&gt;/&lt;int:day&gt;/&apos;, views.params),
    re_path(&apos;params/(\d+)/(\d+)/(\d+)/&apos;,views.params),
    re_path(&apos;params/(?P&lt;year&gt;\d+)/(?P&lt;month&gt;\d+)/(?P&lt;day&gt;\d+)/&apos;,views.params)
]

def params(request, year, month, day):
    return HttpResponse(&apos;%s年%s月%s日&apos; % (year,month,day))

def get_uuid(request):
    uid = str(uuid.uuid4())
    return HttpResponse(uid)
</code></pre>
      
    </div><!-- .entry-content -->

    <footer class="entry-meta">
    <a href="/2019/01/07/模板设计/">
    <time datetime="2019-01-07T11:32:25.000Z" class="entry-date">
        2019-01-07
    </time>
</a>
    
    
    </footer>
</article>






  
    <article id="post-模型设计" class="post-模型设计 post type-post status-publish format-standard hentry">
    <!---->

      <header class="entry-header">
        
        
  
    <h1 class="entry-title">
      <a class="article-title" href="/2019/01/04/模型设计/">模型设计</a>
    </h1>
  

        
        <div class="comments-link">
            
            <a href="javascript:void(0);" data-url="http://yoursite.com/2019/01/04/模型设计/" data-id="cjqpf0mcm0007msurew2mrmmc" class="leave-reply bdsharebuttonbox" data-cmd="more">分享</a>
        </div><!-- .comments-link -->
      </header><!-- .entry-header -->

    <div class="entry-content">
      
        <h2 id="1模型设计部分参数"><a href="#1模型设计部分参数" class="headerlink" title="1模型设计部分参数"></a>1模型设计部分参数</h2><h3 id="1-1迁移表中db-table"><a href="#1-1迁移表中db-table" class="headerlink" title="1.1迁移表中db_table"></a>1.1迁移表中db_table</h3><p>指定db_table参数，表示模型迁移时，映射到数据库中的表名称<br>如果没指定db_table参数，则数据库中模型映射的表名为：应用名(app)_模型名</p>
<h3 id="1-2模型中的外键约束中的on-delete参数"><a href="#1-2模型中的外键约束中的on-delete参数" class="headerlink" title="1.2模型中的外键约束中的on_delete参数"></a>1.2模型中的外键约束中的on_delete参数</h3><p>on_delete=models.CASCADE:不能删除主表，从表相应数据可以被删除（默认）<br>on_delete=models.PROTECT：不让删主表，但可以删从表<br>on_delete=models.SET_NULL：删除主表，从表的关联字段(外键)设置为空</p>
<h3 id="1-3模型中外键约束中的related-name参数"><a href="#1-3模型中外键约束中的related-name参数" class="headerlink" title="1.3模型中外键约束中的related_name参数"></a>1.3模型中外键约束中的related_name参数</h3><p>related_name:关联对象反向引用描述符<br>related_name=’info’：给反向引用描述符命名为info；如果不设置，则默认为模型名的全小写</p>
<h2 id="2模型设计部分字段类型"><a href="#2模型设计部分字段类型" class="headerlink" title="2模型设计部分字段类型"></a>2模型设计部分字段类型</h2><p>CharField:字符串类型<br>TextField：存储长文本内容，前端的areatext标签<br>IntegerField:整型<br>ImageField:字符串类型，用于存图片<br>BooleanField:布尔，True或者False<br>DateTimeField:日期，年月日时分秒<br>DateField：年月日<br>FloatField：浮点类型</p>
<p>DecimalField：浮点类型，限制最大长度和小数点后的长度<br>unique：是否唯一<br>default：默认值<br>null：是否可以为空</p>
<p>primary_key：主键（电脑可以自己赋值）<br>auto_now_add:创建时，默认赋值为当前时间<br>auto_now：在创建或者修改时，默认赋值为当前时间（更新时只能用save方法更新）<br>max_length:最大长度</p>
<h2 id="3一对一模型中给从表添加对象"><a href="#3一对一模型中给从表添加对象" class="headerlink" title="3一对一模型中给从表添加对象"></a>3一对一模型中给从表添加对象</h2><p>一对一（OneToOneField），常写作（1：1），定义在模型中的任何一方都可以<br>存储：<br>    关联字段存储1：stu_info.关联字段=关联对象<br>        stu_info.stu=Student.objects.get(id=1)<br>    关联字段存储2: stu_info.关联字段_id=主键id值<br>        stu_info.stu_id=1<br>查询：<br>    学生对象查拓展表对象：学生对象.拓展模型名称的小写<br>    拓展表查询学生对象：拓展表对象.外键约束字段<br>学生与其紧急联系人之间为一对一模型关系<br>先在models中创建StudentInfo模型</p>
<pre><code>class StudentInfo(models.Model):
    s_no = models.CharField(max_length=10,null=False)
    phone = models.CharField(max_length=11,null=True)
    name = models.CharField(max_length=10,null=True)
    设置stu字段并为其设置为1对1属性
    stu = models.OneToOneField(Student,on_delete=models.SET_NULL,
                           related_name=&apos;info&apos;,null=True)
</code></pre><p>在对从表添加数据并为其主键赋值时，有两种写法<br>stu_info（从表对象）.stu（从表字段）=Student.objects.get(id=1)（主表具体的对象）<br>stu_info.stu_id（外键）=1（主表对应的主键）；功能都是相同的。</p>
<h3 id="3-1对外键赋值方法一"><a href="#3-1对外键赋值方法一" class="headerlink" title="3.1对外键赋值方法一"></a>3.1对外键赋值方法一</h3><pre><code>def add_stu_info(request):
    stu_info = StudentInfo()
    stu_info.s_no=&apos;12556&apos;
    stu_info.phone=&apos;13981366521&apos;
    stu_info.name=&apos;小王&apos;
    stu_info.stu=Student.objects.get(id=1)
    stu_info.save()
    return HttpResponse(&apos;创建拓展信息成功&apos;)
</code></pre><h3 id="3-2对外键赋值方法二"><a href="#3-2对外键赋值方法二" class="headerlink" title="3.2对外键赋值方法二"></a>3.2对外键赋值方法二</h3><pre><code>def add_stu_info(request):
    stu_info = StudentInfo()
    stu_info.s_no=&apos;12556&apos;
    stu_info.phone=&apos;13981366521&apos;
    stu_info.name=&apos;小王&apos;
    stu_info.stu_id=1
    stu_info.save()
    return HttpResponse(&apos;创建拓展信息成功&apos;)
</code></pre><h2 id="4一对一模型中通过主表查询从表（不用related-name参数）"><a href="#4一对一模型中通过主表查询从表（不用related-name参数）" class="headerlink" title="4一对一模型中通过主表查询从表（不用related_name参数）"></a>4一对一模型中通过主表查询从表（不用related_name参数）</h2><p>过程：<br>1.查询主表（学生）对象<br>2.通过主表（学生）对象查询从表（拓展表）对象<br>在主表查从表获取连表条件时有两种写法：<br>stu_info=StudentInfo.objects.filter(stu（从表字段）=stu（主表对象）).first()<br>stu_info=StudentInfo.objects.filter(stu_id（从表字段）=stu.id（主表对象的属性）).first()</p>
<h3 id="4-1查询方法1"><a href="#4-1查询方法1" class="headerlink" title="4.1查询方法1"></a>4.1查询方法1</h3><pre><code>def sel_phone_by_stu(request):
    stu=Student.objects.filter(s_name=&apos;小明&apos;).first()
    stu_info=StudentInfo.objects.filter(stu=stu).first()
    phone=stu_info.phone
    return HttpResponse(&apos;查询电话成功&apos;)
</code></pre><h3 id="4-2查询方法2"><a href="#4-2查询方法2" class="headerlink" title="4.2查询方法2"></a>4.2查询方法2</h3><pre><code>def sel_phone_by_stu(request):
    stu=Student.objects.filter(s_name=&apos;小明&apos;).first()
    stu_info=StudentInfo.objects.filter(stu_id=stu.id).first()
    phone=stu_info.phone
    return HttpResponse(&apos;查询电话成功&apos;)
</code></pre><h2 id="5一对一模型中通过主表查询从表（用related-name参数）"><a href="#5一对一模型中通过主表查询从表（用related-name参数）" class="headerlink" title="5一对一模型中通过主表查询从表（用related_name参数）"></a>5一对一模型中通过主表查询从表（用related_name参数）</h2><p>反向引用过程：<br>1.查询学生对象<br>2.反向查询；关联模型对象，关联另外一个模型的名称的小写</p>
<h3 id="5-1使用模型中默认的related-name参数"><a href="#5-1使用模型中默认的related-name参数" class="headerlink" title="5.1使用模型中默认的related_name参数"></a>5.1使用模型中默认的related_name参数</h3><p>模型中默认的related_name参数为模型名的全小写</p>
<pre><code>def sel_phone_by_stu2(request):
    stu=Student.objects.filter(s_name=&apos;小明&apos;).first()
    stu_info = stu.studentinfo #studentinfo反向引用符
    phone=stu_info.phone
    print(phone)
    return HttpResponse(&apos;查询电话成功&apos;)
</code></pre><h3 id="5-2使用设置的related-name参数"><a href="#5-2使用设置的related-name参数" class="headerlink" title="5.2使用设置的related_name参数"></a>5.2使用设置的related_name参数</h3><p>在模型中的主键中设置：stu = models.OneToOneField(Student,on_delete=models.SET_NULL,<br> related_name=’info’,null=True)；将related_name设置为info</p>
<pre><code>def sel_phone_by_stu2(request):
    stu=Student.objects.filter(s_name=&apos;小明&apos;).first()
    stu_info = stu.info #info反向引用符
    phone=stu_info.phone
    print(phone)
    return HttpResponse(&apos;查询电话成功&apos;)
</code></pre><h2 id="6一对一模型中通过从表查询主表"><a href="#6一对一模型中通过从表查询主表" class="headerlink" title="6一对一模型中通过从表查询主表"></a>6一对一模型中通过从表查询主表</h2><p>1.查询拓展表信息<br>2.查询学生对象</p>
<pre><code>def sel_stu_by_info(request):
    stu_info=StudentInfo.objects.filter(s_no=&apos;12556&apos;).first()
    stu（学生对象）=stu_info（拓展对象）.stu（拓展表字段）
    print(stu.s_name)
    return HttpResponse(&apos;查询成功&apos;)
</code></pre><h2 id="7一对一模型中删除信息"><a href="#7一对一模型中删除信息" class="headerlink" title="7一对一模型中删除信息"></a>7一对一模型中删除信息</h2><p>当模型中为关联字段设置on_delete时，各参数的意义；<br>stu = models.OneToOneField(Student,on_delete=models.SET_NULL）<br>on_delete=models.CASCADE:不能删除主表，从表相应数据可以被删除（默认）<br>on_delete=models.PROTECT：不让删主表，但可以删从表<br>on_delete=models.SET_NULL：删除主表，从表的关联字段(外键)设置为空</p>
<pre><code>def on_delete_stu(request):
    Student.objects.filter(s_name=&apos;小明&apos;).delete()
    return HttpResponse(&apos;删除成功&apos;)
</code></pre><h2 id="8一对多模型中创建班级"><a href="#8一对多模型中创建班级" class="headerlink" title="8一对多模型中创建班级"></a>8一对多模型中创建班级</h2><p>一对多（ForeignKey），常写作（1：N），定义在多的一方<br>存储（给学生设置班级）：<br>    关联字段的存储1：学生对象.关系字段=关联模型对象<br>    关联字段的存储2：学生对象.关系字段_id=关联表的主键id值<br>查询：<br>若没有定义related_name参数：<br>    学生查询班级：班级对象=多的一方（学生）对象.关联字段<br>    班级查询学生：一的一方（班级）.关联模型名的小写_s<br>若定义了related_name参数：<br>    学生查班级：多的一方（学生）对象.关联字段<br>    班级查询学生：一的一方（班级）.related_name参数名<br>先创建一个班级模型；班级与学生之间为一对多模型</p>
<pre><code>class Grade(models.Model):
    g_name=models.CharField(max_length=10,unique=True)
    class Meta:
        db_table=&apos;grade&apos;

def add_grade(request):
    Grade.objects.create(g_name=&apos;java1807&apos;)
    return HttpResponse(&apos;添加班级成功&apos;)
</code></pre><h2 id="9给学生设置班级"><a href="#9给学生设置班级" class="headerlink" title="9给学生设置班级"></a>9给学生设置班级</h2><pre><code>def stu_grade(request):
    stu=Student.objects.get(pk=4)
    stu.g_id=1 #给该对象的g_id属性（班级）赋值为1
    stu.save()
    return HttpResponse(&apos;分配学生班级成功&apos;)
</code></pre><h2 id="10通过学生查询班级"><a href="#10通过学生查询班级" class="headerlink" title="10通过学生查询班级"></a>10通过学生查询班级</h2><pre><code>def sel_grade_by_stu(request):
    # 获取姓名叫小明2的学生对象
    stu=Student.objects.get(s_name=&apos;小明2&apos;)
    # 获取班级对象
    grade=stu.g
    print(grade.g_name)
    return HttpResponse(&apos;查询成功&apos;)
</code></pre><h2 id="11通过班级查询学生"><a href="#11通过班级查询学生" class="headerlink" title="11通过班级查询学生"></a>11通过班级查询学生</h2><pre><code>def sel_stu_by_grade(request):
    grade=Grade.objects.get(g_name=&apos;python1808&apos;)
    stus=grade.student_set.all()
    print(stus)#返回含有对象的列表
    stus=grade.student_set
    print(stus)#返回app.Student.None
    return HttpResponse(&apos;查询成功&apos;)
</code></pre><h2 id="12多对多模型中创建课程"><a href="#12多对多模型中创建课程" class="headerlink" title="12多对多模型中创建课程"></a>12多对多模型中创建课程</h2><p>多对多（ManyToManyField），常写作（N：M），可以定义在模型中的任何一方<br>多对多的存储同一对多一样；<br>1.在查询方面如果没有设置related_name参数；<br>    当用课程查询学生时，查询方式为：课程对象.关联字段.filter（）<br>    用学生查询课程时，查询方式为：学生对象.关联模型名的小写_set<br>2.如果设置了related_name参数：<br>    用课程查询学生:课程对象.关联字段.filter().all()<br>    用学生查询课程:学生对象.related_name参数.filter().all()<br>创建一个课程表，课程与学生之间为多对多关系</p>
<pre><code>class Course(models.Model):
    c_name=models.CharField(max_length=10,unique=True)
    # ManyToManyField字段定义在任何一个模型都可以
    stu=models.ManyToManyField(Student,null=True)
    class Meta:
        db_table=&apos;course&apos;
</code></pre><p>往课程表中添加课程</p>
<pre><code>def add_course(request):
    c_names=[&apos;大学英语&apos;,&apos;高等数学&apos;,&apos;岩浆岩岩石学&apos;,
         &apos;线性代数&apos;,&apos;概率论&apos;,&apos;运筹学&apos;]
    for name in c_names:
        cou = Course()
        cou.c_name=name
        cou.save()
    return HttpResponse(&apos;添加课程成功&apos;)
</code></pre><h2 id="13通过中间表添加删除学生或者课程"><a href="#13通过中间表添加删除学生或者课程" class="headerlink" title="13通过中间表添加删除学生或者课程"></a>13通过中间表添加删除学生或者课程</h2><h3 id="13-1给学生添加课程"><a href="#13-1给学生添加课程" class="headerlink" title="13.1给学生添加课程"></a>13.1给学生添加课程</h3><pre><code>def add_s_c(request):
    cou=Course.objects.get(c_name=&apos;高等数学&apos;)
    stu=Student.objects.get(s_name=&apos;妲己&apos;)
    stu.course_set.add(cou)
    return HttpResponse(&apos;添加中间表成功&apos;)
</code></pre><h3 id="13-2给课程添加学生"><a href="#13-2给课程添加学生" class="headerlink" title="13.2给课程添加学生"></a>13.2给课程添加学生</h3><pre><code>def add_s_c(request):
    cou=Course.objects.get(c_name=&apos;高等数学&apos;)
    stu=Student.objects.get(s_name=&apos;妲己&apos;)
    cou.stu(学生模型中反向引用符).add(stu(学生对象))
    return HttpResponse(&apos;添加中间表成功&apos;)
</code></pre><h3 id="13-3学生删除课程"><a href="#13-3学生删除课程" class="headerlink" title="13.3学生删除课程"></a>13.3学生删除课程</h3><pre><code>def add_s_c(request):
    cou=Course.objects.get(c_name=&apos;高等数学&apos;)
    stu=Student.objects.get(s_name=&apos;妲己&apos;)
    stu.course_set.remove(cou)
    return HttpResponse(&apos;添加中间表成功&apos;)
</code></pre><h2 id="14前端设计"><a href="#14前端设计" class="headerlink" title="14前端设计"></a>14前端设计</h2><h3 id="14-1配置"><a href="#14-1配置" class="headerlink" title="14.1配置"></a>14.1配置</h3><p>在settings.py文件中定义TEMPALTES的目录地址第58行添加如下文字：’DIRS’: [os.path.join(BASE_DIR,’templates’)],<br>os.path.join(BASE_DIR,’templates’)中BASE_DIR表示第16行的BASE_DIR获取到的文件位置，templates表示含有网页文件的文件夹；os.path.join（’a’,’b’）表示文件路径：a//b</p>
<h3 id="14-2后端渲染模板"><a href="#14-2后端渲染模板" class="headerlink" title="14.2后端渲染模板"></a>14.2后端渲染模板</h3><p>使用render()渲染模板<br>传递参数给模板,render(request,模板名,{key1:value1,key2:value2})</p>
<pre><code>from django.shortcuts import render
def index(request):
    stus=Student.objects.all()
    return render(request,&apos;index.html&apos;,{&apos;a&apos;:stus})
</code></pre><h3 id="14-3前端渲染模板"><a href="#14-3前端渲染模板" class="headerlink" title="14.3前端渲染模板"></a>14.3前端渲染模板</h3><p>1.解析变量：<br>2.解析标签：{\% 标签 %}{\% endfor标签 %}</p>
<pre><code>{{ a }} #解析变量
&lt;br&gt; #换行标签
{% for stu in a %} #for标签
        <p>姓名：{{ stu.s_name }}
            年龄：{{ stu.s_age }}
            班级：{{ stu.g.g_name }}
            选课：
            {% for c in stu.course_set.all %}
                {{ c.c_name }}
                {% endfor %}
    &lt;/p&gt;
{% endfor %} #结束标签
</p></code></pre><h2 id="15总结"><a href="#15总结" class="headerlink" title="15总结"></a>15总结</h2><h3 id="15-1聚合函数及模糊查询"><a href="#15-1聚合函数及模糊查询" class="headerlink" title="15.1聚合函数及模糊查询"></a>15.1聚合函数及模糊查询</h3><p>聚合函数(Avg,Max,Sum,Count)的使用<br>模型名.objects.筛选条件.aggregate(聚合函数(‘聚合条件’))<br>模糊查询（contains、startswith及endswith）<br>模型名.objects.filter(查询字段__startswith=’查询内容’)</p>
<h3 id="15-2related-name参数"><a href="#15-2related-name参数" class="headerlink" title="15.2related_name参数"></a>15.2related_name参数</h3><p>模型中外键约束中的related_name参数：<br>related_name:关联对象反向引用描述符；当为一对一关系时，related_name参数默认为对应模型的模型名全小写；当为一对多或者多对多关系时，默认为对应模型的模型名小写_set</p>
<h3 id="15-3用主表给从表关联字段赋值"><a href="#15-3用主表给从表关联字段赋值" class="headerlink" title="15.3用主表给从表关联字段赋值"></a>15.3用主表给从表关联字段赋值</h3><p>当用主表中的信息(主键)给从表的关联字段(外键)赋值时：<br>从表对象.关联字段=主表对象(主表对象要唯一) 或者 从表对象.关联字段_id=要赋的主表对象对应的主键具体值</p>
<h3 id="15-4不用related-name用主表查从表"><a href="#15-4不用related-name用主表查从表" class="headerlink" title="15.4不用related_name用主表查从表"></a>15.4不用related_name用主表查从表</h3><p>当不用related_name参数查询时：<br>当用主表查从表时（无关联参数的一方查有关联参数的一方），先生成主表对象；然后从表对象=从表模型名.objects.filter(关联字段=主表对象/关联字段_id=主表对象.id).first()</p>
<h3 id="15-5用related-name查询"><a href="#15-5用related-name查询" class="headerlink" title="15.5用related_name查询"></a>15.5用related_name查询</h3><p>当用related_name参数查询时：<br>当用主表查从表时（无关联参数的一方查有关联参数的一方），需要用related_name参数生成从表对象(从表对象=主表对象.related_name参数/当为一对多关系时，还要在后面接上.all()才是查询集集合)<br>当用从表查主表时（有关联参数的一方查无关联参数的一方），直接用关联字段生成主表对象(主表对象=从表对象.关联字段)</p>
<h3 id="15-6多对多中间表数据的添加与删除"><a href="#15-6多对多中间表数据的添加与删除" class="headerlink" title="15.6多对多中间表数据的添加与删除"></a>15.6多对多中间表数据的添加与删除</h3><p>当为多(M)对多(N)关系时：<br>往中间表中添加数据：M对象.N的related_name参数.add(N对象)<br>在中间表中删除数据：M对象.N的related_name参数.remove(N对象)</p>

      
    </div><!-- .entry-content -->

    <footer class="entry-meta">
    <a href="/2019/01/04/模型设计/">
    <time datetime="2019-01-04T12:32:25.000Z" class="entry-date">
        2019-01-04
    </time>
</a>
    
    
    </footer>
</article>






  
    <article id="post-模型关系映射" class="post-模型关系映射 post type-post status-publish format-standard hentry">
    <!---->

      <header class="entry-header">
        
        
  
    <h1 class="entry-title">
      <a class="article-title" href="/2019/01/03/模型关系映射/">模型关系映射</a>
    </h1>
  

        
        <div class="comments-link">
            
            <a href="javascript:void(0);" data-url="http://yoursite.com/2019/01/03/模型关系映射/" data-id="cjqpf0mau0002msur32xi0f9r" class="leave-reply bdsharebuttonbox" data-cmd="more">分享</a>
        </div><!-- .comments-link -->
      </header><!-- .entry-header -->

    <div class="entry-content">
      
        <p>导入函数或者文件方法：先写一个函数名或者其他，然后按alt+enter<br>ctrl+d 快速复制当前行并粘贴到下一行<br>ctrl+y 删除当前行<br>模型层<br> ORM技术:对象关系映射  —objects relationship mapping<br>对象关系映射：将模型中的语句映射为数据库中的语句，可以通过编写模型中的语句对数据库(多种)进行操作<br>objects：管理器，默认模型的属性<br>在orm技术中，pk代表表格的主键（primary key）</p>
<h2 id="1-添加学生对象（create）"><a href="#1-添加学生对象（create）" class="headerlink" title="1 添加学生对象（create）"></a>1 添加学生对象（create）</h2><p>创建 create（）方法：模型名.objects.create(字段1=值，字段2=值)<br>save方法：模型对象.save（）</p>
<h3 id="1-1-create方法"><a href="#1-1-create方法" class="headerlink" title="1.1 create方法"></a>1.1 create方法</h3><pre><code>def add_stu(request):
    Student.objects.create(s_name=&apos;小明&apos;)
    return HttpResponse(&apos;创建学生成功&apos;)
</code></pre><h3 id="1-2-save方法"><a href="#1-2-save方法" class="headerlink" title="1.2 save方法"></a>1.2 save方法</h3><pre><code>def add_stu(request):
    stu = Student()
    stu.s_name = &apos;老王&apos;
    stu.s_gender = 1
    stu.save()
    return HttpResponse(&apos;创建学生成功&apos;)
</code></pre><h2 id="2-删除学生"><a href="#2-删除学生" class="headerlink" title="2 删除学生"></a>2 删除学生</h2><p>删除学生的步骤：<br>1.获取删除的对象，filter(条件)<br> 2.实现删除方法 delete()<br>删除 delete（）方法：模型名.objects.filter(条件).delete()</p>
<pre><code>def del_stu(request):
    Student.objects.filter(id=13).delete()
    return HttpResponse(&apos;删除成功&apos;)
</code></pre><h2 id="3-更新（修改）学生"><a href="#3-更新（修改）学生" class="headerlink" title="3 更新（修改）学生"></a>3 更新（修改）学生</h2><p>更新学生步骤：<br>1.获取更新的数据，filter（条件）<br> 2.实现更新方法， update（）<br>修改 update（）方法：模型名.objects.filter(条件).update(字段1=值，字段2=值)<br>save（）方法：模型对象.save<br>update（）和save（）的区别：是否更新使用auto_now约束条件的字段，（update不更新）</p>
<h3 id="3-1update方法"><a href="#3-1update方法" class="headerlink" title="3.1update方法"></a>3.1update方法</h3><pre><code>def up_stu(request):
    Student.objects.filter(id=4).update(s_name=&apos;妲己&apos;)
    return HttpResponse(&apos;更新成功&apos;)
</code></pre><h3 id="3-2save方法"><a href="#3-2save方法" class="headerlink" title="3.2save方法"></a>3.2save方法</h3><pre><code>def up_stu(request):
    stu = Student.objects.filter(id=2).first()
    stu.s_name = &apos;妲己2&apos;
    stu.save()
    return HttpResponse(&apos;更新成功&apos;)
</code></pre><h2 id="4查询学生"><a href="#4查询学生" class="headerlink" title="4查询学生"></a>4查询学生</h2><h3 id="4-1查询所有学生"><a href="#4-1查询所有学生" class="headerlink" title="4.1查询所有学生"></a>4.1查询所有学生</h3><p>查询所有的学生信息,all()，返回一组对象的列表</p>
<pre><code>def sel_stu(request):
    stus = Student.objects.all()
    for stu in stus:
        print(stu.s_name)
</code></pre><h3 id="4-2查询特定的单个学生"><a href="#4-2查询特定的单个学生" class="headerlink" title="4.2查询特定的单个学生"></a>4.2查询特定的单个学生</h3><h4 id="4-2-1filter方法"><a href="#4-2-1filter方法" class="headerlink" title="4.2.1filter方法"></a>4.2.1filter方法</h4><p>返回的是queryset对象</p>
<pre><code>stu5 = Student.objects.filter(id=6)
print(stu)  # &lt;QuerySet [&lt;Student: Student object (6)&gt;]&gt;
</code></pre><p>first()：取出结果中的第一个对象</p>
<pre><code>stu = Student.objects.filter(id=6).first()
print(stu)  # Student object (6)
</code></pre><h4 id="4-2-2get（）方法"><a href="#4-2-2get（）方法" class="headerlink" title="4.2.2get（）方法"></a>4.2.2get（）方法</h4><p>get（）只能用来取唯一的一个对象<br>get（条件）条件必须成立才能使用</p>
<pre><code>stu = Student.objects.get(id=6)
print(stu)  # Student object (6)（返回id为6的学生对象）
</code></pre><h3 id="4-3查询特定的多个学生"><a href="#4-3查询特定的多个学生" class="headerlink" title="4.3查询特定的多个学生"></a>4.3查询特定的多个学生</h3><pre><code>stus = Student.objects.filter(s_gender=1)
print(stus) #查询所有的男性
</code></pre><h3 id="4-4exclude（条件）方法"><a href="#4-4exclude（条件）方法" class="headerlink" title="4.4exclude（条件）方法"></a>4.4exclude（条件）方法</h3><p>exclude(条件):过滤出不满足条件的信息</p>
<pre><code>stus = Student.objects.exclude(s_gender=0)
print(stus)#查询所有性别为女的之外的性别的人（即查询全部男性）
</code></pre><h3 id="4-5order-by-排序方法"><a href="#4-5order-by-排序方法" class="headerlink" title="4.5order_by()排序方法"></a>4.5order_by()排序方法</h3><p>order_by（’id’）,升序<br>order_by（’-id’）,降序</p>
<pre><code>stus = Student.objects.order_by(&apos;id&apos;)
print(stus)
</code></pre><h3 id="4-6values（）方法"><a href="#4-6values（）方法" class="headerlink" title="4.6values（）方法"></a>4.6values（）方法</h3><p>values（）取出对象中的某个字段-返回的是一个列表，列表中为字典</p>
<pre><code>stus = Student.objects.all().values(&apos;s_name&apos;, &apos;s_age&apos;) #取所有人的姓名和年龄
stus1 = Student.objects.all().values() #取所有人的所有信息
print(stus, stus1)
</code></pre><h3 id="4-7exists-方法、len-方法及count-方法"><a href="#4-7exists-方法、len-方法及count-方法" class="headerlink" title="4.7exists()方法、len()方法及count()方法"></a>4.7exists()方法、len()方法及count()方法</h3><p>exists()方法 - 判断查询信息存在否，返回布尔值</p>
<pre><code># 判断小张这个人存在不
a = Student.objects.filter(s_name=&apos;小张&apos;).exists()
print(a)  # False

stus = Student.objects.filter(s_gender=1)
# len查看查询结果的长度
print(len(stus))  # 2

# count统计查询结果元素的个数
b = Student.objects.filter(s_gender=1).count()
print(b)  # 2
</code></pre><h3 id="4-8模糊查询（contains、startswith及endswith）"><a href="#4-8模糊查询（contains、startswith及endswith）" class="headerlink" title="4.8模糊查询（contains、startswith及endswith）"></a>4.8模糊查询（contains、startswith及endswith）</h3><h4 id="4-8-1contains方法"><a href="#4-8-1contains方法" class="headerlink" title="4.8.1contains方法"></a>4.8.1contains方法</h4><p>contains:包含，模糊查询；语法，字段__contains=</p>
<pre><code>stus = Student.objects.filter(s_name__contains=&apos;小明&apos;)
print(stus)
</code></pre><h4 id="4-8-2startswith方法"><a href="#4-8-2startswith方法" class="headerlink" title="4.8.2startswith方法"></a>4.8.2startswith方法</h4><p>startswith:以什么开头</p>
<pre><code>stus = Student.objects.filter(s_name__startswith=&apos;小&apos;)
print(stus)
</code></pre><h4 id="4-8-3endswith方法"><a href="#4-8-3endswith方法" class="headerlink" title="4.8.3endswith方法"></a>4.8.3endswith方法</h4><p>endswith:以什么结束</p>
<pre><code>stus = Student.objects.filter(s_name__endswith=&apos;明&apos;)
print(stus)
</code></pre><h3 id="4-9in方法"><a href="#4-9in方法" class="headerlink" title="4.9in方法"></a>4.9in方法</h3><p>in：查询在某个范围之内</p>
<pre><code>stus = Student.objects.filter(id__in=[1, 2, 3, 4, 5])
print(stus)

stus = Student.objects.filter(pk__in=[1, 2, 3, 4, 5])
print(stus)
</code></pre><p>pk代表主键，而id是这个学生表的主键，所以结果将一样</p>
<h3 id="4-10大于及小于符号"><a href="#4-10大于及小于符号" class="headerlink" title="4.10大于及小于符号"></a>4.10大于及小于符号</h3><p>gte:大于等于；gt：大于；lte：小于等于；lt：小于<br>在比较符号后面必须是一个值</p>
<pre><code>stus = Student.objects.filter(s_age__gte=21, s_age__lte=23)
stus=Student.objects.filter(s_age__gte=21).filter(s_age__lte=23)
</code></pre><p>上面两条语句的结果相同，都为查询年龄大于等于21且小于等于23的人</p>
<h3 id="4-11与或非"><a href="#4-11与或非" class="headerlink" title="4.11与或非"></a>4.11与或非</h3><p>用与或非语句的时候，需要先导入Q方法</p>
<h4 id="4-11-1与"><a href="#4-11-1与" class="headerlink" title="4.11.1与"></a>4.11.1与</h4><pre><code>stus = Student.objects.filter(s_age__gte=21, s_age__lte=23)
stus = Student.objects.filter(Q(s_age__gte=21), Q(s_age__lte=23))
stus = Student.objects.filter(Q(s_age__gte=21) and Q(s_age__lte=23))
stus = Student.objects.filter(Q(s_age__gte=21) &amp; Q(s_age__lte=23))
</code></pre><h4 id="4-11-2或"><a href="#4-11-2或" class="headerlink" title="4.11.2或"></a>4.11.2或</h4><pre><code>stus = Student.objects.filter(Q(s_age__gte=21) or Q(s_age__lte=23))
stus = Student.objects.filter(Q(s_age__gte=21) | Q(s_age__lte=23))
</code></pre><h4 id="4-11-3非"><a href="#4-11-3非" class="headerlink" title="4.11.3非"></a>4.11.3非</h4><pre><code>stus = Student.objects.filter(~Q(s_age__gte=21))
</code></pre><h4 id="4-11-4对象字段比较F（）方法"><a href="#4-11-4对象字段比较F（）方法" class="headerlink" title="4.11.4对象字段比较F（）方法"></a>4.11.4对象字段比较F（）方法</h4><p>查询物理成绩大于数学成绩的学生</p>
<pre><code>stus = Student.objects.all()
for stu in stus:
    if (stu.wuli &gt; stu.math):
        print(stu.s_name)
</code></pre><p>上面方法也能达到要求，但不推荐；推荐使用下面方法<br> F(‘math’):取math对应的值</p>
<pre><code>stus = Student.objects.filter(wuli__gt=F(&apos;math&apos;))
</code></pre><h3 id="4-12聚合函数Avg-Max-Sum-Count"><a href="#4-12聚合函数Avg-Max-Sum-Count" class="headerlink" title="4.12聚合函数Avg,Max,Sum,Count"></a>4.12聚合函数Avg,Max,Sum,Count</h3><pre><code>def sel_stu(request):
    age_avg = Student.objects.all().aggregate(Avg(&apos;s_age&apos;))
    print(age_avg)
    age_sum = Student.objects.all().aggregate(Sum(&apos;s_age&apos;))
    print(age_sum)
    return HttpResponse(&apos;查询所有学生信息&apos;)
</code></pre>
      
    </div><!-- .entry-content -->

    <footer class="entry-meta">
    <a href="/2019/01/03/模型关系映射/">
    <time datetime="2019-01-03T12:22:25.000Z" class="entry-date">
        2019-01-03
    </time>
</a>
    
    
    </footer>
</article>






  
    <article id="post-django环境搭建" class="post-django环境搭建 post type-post status-publish format-standard hentry">
    <!---->

      <header class="entry-header">
        
        
  
    <h1 class="entry-title">
      <a class="article-title" href="/2019/01/02/django环境搭建/">django环境搭建</a>
    </h1>
  

        
        <div class="comments-link">
            
            <a href="javascript:void(0);" data-url="http://yoursite.com/2019/01/02/django环境搭建/" data-id="cjqpf0m9l0000msurqjmx8gte" class="leave-reply bdsharebuttonbox" data-cmd="more">分享</a>
        </div><!-- .comments-link -->
      </header><!-- .entry-header -->

    <div class="entry-content">
      
        <h2 id="1-无图形化界面安装虚拟环境"><a href="#1-无图形化界面安装虚拟环境" class="headerlink" title="1.无图形化界面安装虚拟环境"></a>1.无图形化界面安装虚拟环境</h2><h3 id="1-1安装虚拟器"><a href="#1-1安装虚拟器" class="headerlink" title="1.1安装虚拟器"></a>1.1安装虚拟器</h3><pre><code>pip install virtualenv
</code></pre><h3 id="1-2创建虚拟环境"><a href="#1-2创建虚拟环境" class="headerlink" title="1.2创建虚拟环境"></a>1.2创建虚拟环境</h3><pre><code>virtual --no-site-packages -p D:\python3\python.exe name
</code></pre><p>–no-site-packages：表示创建的虚拟环境为纯净的环境，不安装有其他的库<br>-p D:\python3\python.exe 使用的python版本及其地址（当电脑中只有一个python版本时，此步可省略）<br>name 虚拟库的名字</p>
<h3 id="1-3pip使用"><a href="#1-3pip使用" class="headerlink" title="1.3pip使用"></a>1.3pip使用</h3><pre><code>pip list  查看安装的库
</code></pre><p>pip install xxx 安装xxx的库</p>
<h3 id="1-4激活虚拟环境"><a href="#1-4激活虚拟环境" class="headerlink" title="1.4激活虚拟环境"></a>1.4激活虚拟环境</h3><p>windwos下直接执行activate命令<br>mac/linux/ubuntu:直接执行source activate命令</p>
<pre><code>activate
</code></pre><h3 id="1-5退出虚拟环境"><a href="#1-5退出虚拟环境" class="headerlink" title="1.5退出虚拟环境"></a>1.5退出虚拟环境</h3><p>直接执行deactivate命令</p>
<pre><code>deactivate
</code></pre><h3 id="1-6创建django项目"><a href="#1-6创建django项目" class="headerlink" title="1.6创建django项目"></a>1.6创建django项目</h3><p>1.在虚拟环境中先激活虚拟环境：activate<br>2.在激活环境下进入想要创建到的位置文件夹 cd ../cd<br>3.创建django项目：django-admin startproject day01</p>
<p>启动命令：python manage.py runserver 默认ip为127.0.0.1 默认端口为8000<br>修改启动端口：python manage.py runserver 端口<br>修改ip和端口：python manage.py runserver ip:端口<br>ip参数：如果为0.0.0.0表示任何人都可以通过公网访问django项目<br>端口post参数：如果端口设置为80.表示该端口访问时可以不用写</p>
<h2 id="2django项目各文件的意义"><a href="#2django项目各文件的意义" class="headerlink" title="2django项目各文件的意义"></a>2django项目各文件的意义</h2><h3 id="2-1-manager-py"><a href="#2-1-manager-py" class="headerlink" title="2.1 manager.py"></a>2.1 manager.py</h3><p>manager.py启动文件</p>
<h3 id="2-2-init-py"><a href="#2-2-init-py" class="headerlink" title="2.2__init__.py"></a>2.2__init__.py</h3><p><strong>init</strong>.py包文件:可以通过这个文件将该包下的文件导入其他文件</p>
<h3 id="2-3settings-py-配置文件"><a href="#2-3settings-py-配置文件" class="headerlink" title="2.3settings.py 配置文件"></a>2.3settings.py 配置文件</h3><pre><code>os.path.abspath(__file__)：当前文件的绝对路径
os.path.dirname(os.path.abspath(__file__))：当前文件的上层目录的绝对路径
os.path.dirname(os.path.dirname(os.path.abspath(__file__)))：当前文件的上层的上层的目录的绝对路径（即当前项目的绝对路径）
DEBUG = True：调试模式，上线的时候需要将其改层False
ALLOWED_HOSTS = [&quot;*&quot;]：允许访问的主机的ip地址
ROOT_URLCONF = &apos;day01.urls&apos;：根路由
DATABASES ：数据库配置
    STATIC_URL = &apos;/static/&apos; ：配置html文件路径
</code></pre><h3 id="2-4urls-py路由文件"><a href="#2-4urls-py路由文件" class="headerlink" title="2.4urls.py路由文件"></a>2.4urls.py路由文件</h3><p>将网址写在这个文件中，将能在计算机上对其进行访问</p>
<pre><code>path(&apos;admin/&apos;, admin.site.urls)， 在端口后加/admin访问
path(&apos;hello&apos;,views.hello),加的hello后缀指向views文件下的hello函数
</code></pre><h3 id="2-5wsgi-py"><a href="#2-5wsgi-py" class="headerlink" title="2.5wsgi.py"></a>2.5wsgi.py</h3><p>wsgi.py网关文件</p>
<h2 id="3创建一个app文件"><a href="#3创建一个app文件" class="headerlink" title="3创建一个app文件"></a>3创建一个app文件</h2><pre><code>python manage.py startapp app名称 - 创建一个app文件 
</code></pre><p>在app文件夹中一般都是对models.py和views.py两个文件进行操作，其他文件一般不作改动</p>
<h2 id="4MVT模式和MVC模式区别"><a href="#4MVT模式和MVC模式区别" class="headerlink" title="4MVT模式和MVC模式区别"></a>4MVT模式和MVC模式区别</h2><p>MVC模式是所有框架遵循的模式<br>MVT模式是由MVC模式演变而来的</p>
<h3 id="4-1MVC模式"><a href="#4-1MVC模式" class="headerlink" title="4.1MVC模式"></a>4.1MVC模式</h3><pre><code> M：模型层
V：模板，HTML页面
C：controller，控制器，写业务逻辑的地方
</code></pre><h3 id="4-2MVT模式"><a href="#4-2MVT模式" class="headerlink" title="4.2MVT模式"></a>4.2MVT模式</h3><pre><code>M：models.py，模型层，定义模型和数据库中的表之间的关联关系
V；viems.py，视图层，定义业务逻辑
T；templates，模板，定义页面HTML的地方
</code></pre><p>django框架遵循MVT模式</p>
<h2 id="5配置修改"><a href="#5配置修改" class="headerlink" title="5配置修改"></a>5配置修改</h2><h3 id="5-1修改init-py配置"><a href="#5-1修改init-py配置" class="headerlink" title="5.1修改init.py配置"></a>5.1修改<strong>init</strong>.py配置</h3><pre><code>import pymysql
pymysql.install_as_MySQLdb()
</code></pre><p>因为python3无法直接访问数据库，只有通过pymysql安装MySQLdb()驱动来访问数据库</p>
<h3 id="5-2数据库连接配置"><a href="#5-2数据库连接配置" class="headerlink" title="5.2数据库连接配置"></a>5.2数据库连接配置</h3><pre><code>数据库连接
settings.py中配置
USER参数：访问用户
PASSWORD参数：密码
HOST参数：访问数据库的地址
PORT参数：访问数据库的端口
NAME参数:数据库名（必须是已经存在的数据库）
</code></pre><h3 id="5-3数据迁移"><a href="#5-3数据迁移" class="headerlink" title="5.3数据迁移"></a>5.3数据迁移</h3><h4 id="5-3-1第一次迁移"><a href="#5-3-1第一次迁移" class="headerlink" title="5.3.1第一次迁移"></a>5.3.1第一次迁移</h4><pre><code>python manage.py migrate
</code></pre><h4 id="5-3-2第一次后的迁移"><a href="#5-3-2第一次后的迁移" class="headerlink" title="5.3.2第一次后的迁移"></a>5.3.2第一次后的迁移</h4><pre><code>settings.py第33行INSTALLED_APPS的最后添加需要迁移的文件夹
生成迁移文件：python manage.py makemigrations
执行迁移文件：python manage.py migrate
</code></pre><h2 id="6创建表格"><a href="#6创建表格" class="headerlink" title="6创建表格"></a>6创建表格</h2><p>在app文件夹下的models.py文件中创建</p>
<pre><code>from django.db import models
class Student(models.Model):
    s_name=models.CharField(max_length=10,unique=True)#代表字段是字符串类型
    s_age=models.IntegerField(default=20)#代表字段是整型，默认为20
    s_gender=models.BooleanField(default=0)
    # auto_now_add:创建时，默认字段赋值为最新的时间
    create_time=models.DateTimeField(auto_now_add=True)
    # auto_now:修改数据时，自动赋值为更新字段时的时间
    update_time=models.DateTimeField(auto_now=True)

    class Meta:
        db_table=&apos;student&apos;
</code></pre><p>将app文件添加至settings.py文件的33行后面；<br>然后在命令行中输入迁移指令：python manage.py makemigrations将生成一个迁移文件（0001_initial.py）<br>最后执行迁移指令：python manage.py migrate，新建的表格将被上传至数据库。</p>
<h2 id="7创建超级管理员"><a href="#7创建超级管理员" class="headerlink" title="7创建超级管理员"></a>7创建超级管理员</h2><pre><code>python manage.py createsuperuser
</code></pre>
      
    </div><!-- .entry-content -->

    <footer class="entry-meta">
    <a href="/2019/01/02/django环境搭建/">
    <time datetime="2019-01-02T11:01:25.000Z" class="entry-date">
        2019-01-02
    </time>
</a>
    
    
    </footer>
</article>






  
    <article id="post-redis数据库主要语法-及与mysql结合用法示例" class="post-redis数据库主要语法-及与mysql结合用法示例 post type-post status-publish format-standard hentry">
    <!---->

      <header class="entry-header">
        
        
  
    <h1 class="entry-title">
      <a class="article-title" href="/2018/12/30/redis数据库主要语法-及与mysql结合用法示例/">redis数据库主要语法-及与mysql结合用法示例</a>
    </h1>
  

        
        <div class="comments-link">
            
            <a href="javascript:void(0);" data-url="http://yoursite.com/2018/12/30/redis数据库主要语法-及与mysql结合用法示例/" data-id="cjqpf0mc10005msurbwamrwyq" class="leave-reply bdsharebuttonbox" data-cmd="more">分享</a>
        </div><!-- .comments-link -->
      </header><!-- .entry-header -->

    <div class="entry-content">
      
        <p>redis数据库详细语法及说明见[<a href="http://redisdoc.com/]" target="_blank" rel="noopener">http://redisdoc.com/]</a><br>下面仅对其常见的五种数据类型的语法进行介绍</p>
<h2 id="1字符串"><a href="#1字符串" class="headerlink" title="1字符串"></a>1字符串</h2><p>setex（如果键存在才能设置值）<br>setnx（如果键不存在才能设置值）；<br>mset（一次设置多个键值对）<br>mget（一次获取多个键值对）；<br>incr str1 将str1中存储的数字值增1<br>getset（拿到键之前的值并对其进行新的赋值）<br>gitbit(取指定位上的比特看是否为0)<br>setbit（设置或清除指定偏移量上的比特）<br>setbit ab 128 1设置ab键的第128位为1，其余为0<br>type 键:可以查看键的数据类型<br>object encoding 键 :查看底层的数据类型</p>
<h2 id="2哈希表"><a href="#2哈希表" class="headerlink" title="2哈希表"></a>2哈希表</h2><p>哈希表：字典里面的值又是一个字典，最适合用来保存对象<br>hset stu1 stuid 1001<br>hset stu1 name xiaoming<br>hset stu1 gender male<br>hset stu1 birth 1999-12-31<br>hset stu1 addr chengdu<br>type stu1 # hash<br>object encoding stu1 # ziplist<br>hget stu1 gender # 取一个值<br>hgetall stu1 #取所有<br>hvals stu1 # 取所有的值<br>同时设置多个值<br>hmset stu2 stuid 1002 name wangdachui addr mianyang gender male<br>hmget stu2 name gender #同时获取stu2的两个值<br>hdel stu2 gender #删除stu2的性别(只删除字段)<br>hexists stu2 gender #判断存在否</p>
<p>hset stu1 fav 100<br>hset stu2 fav 95.23<br>hincrby stu1 fav 50 #给学生1增加点赞数50<br>hincrbyfloat stu2 fav 100.234 #给学生2的点赞数增加100.234<br>hkeys stu1 # 取stu1的所有键</p>
<h2 id="3列表"><a href="#3列表" class="headerlink" title="3列表"></a>3列表</h2><p>列表中的数据结构分为栈和队列两种<br>经典数据存储结构：</p>
<h3 id="3-1栈"><a href="#3-1栈" class="headerlink" title="3.1栈"></a>3.1栈</h3><p>栈（stack） - FILO - 先进后出 - lpush + lpop/rpush + rpop<br>lpush list1 100 200 300 400 500 600<br>从左边拿<br>lpop list1 #600<br>。。。<br>lpop list1 #100(先进后出)</p>
<h3 id="3-2队列"><a href="#3-2队列" class="headerlink" title="3.2队列"></a>3.2队列</h3><p>队列（queue） - FIFO - 先进先出- lpush + rpop/rpush + lpop<br>lpush list1 100 200 300 400 500 600<br>从右边拿<br>rpop list1 # 100<br>…<br>rpop list1 # 600（后进后出）</p>
<h3 id="3-3列表基本语法"><a href="#3-3列表基本语法" class="headerlink" title="3.3列表基本语法"></a>3.3列表基本语法</h3><p>lpush list1 100 200 300 400 500 #给列表在左边放了五个数据<br>lrange list1 0 -1 #查看列表下标为0到-1的数据（500 400 …）<br>rpush list2 100 200 300 400 500 #给列表在右边放了五个数据<br>lrange list1 0 -1 #查看列表下标为0到-1的数据（100 200 …）</p>
<p>lpop list1#从列表的左边取一个数据（500）<br>rpop list1 #从列表的右边取一个数据（100）<br>rpop list1 #从列表的右边取一个数据（200）</p>
<p>lpush list1 100 200 300 400<br>lindex list13 取出下标为3的元素（100）<br>llen list1 看列表的长度</p>
<p>lrange list2 0-1 查看list2的两个元素<br>brpop(阻塞式从右边取元素)<br>brpop list2 5  5秒内取list2中的元素，如果超过5秒没有取到东西就返回nil和等待时长</p>
<h2 id="4集合"><a href="#4集合" class="headerlink" title="4集合"></a>4集合</h2><p>set<br>集合中不能放重复元素<br>sadd set1 100 200 100 #创建一个集合<br>smembers set2 #查看集合中的所有元素<br>sinter set1 set2 # 求交集<br>sdiff set1 set2 #求差集<br>sunion set1 set2 # 求并集<br>srem set1 100 #删除100这个元素<br>sismember set1 200 # 查看200是否在集合1中<br>scard set1 #查看集合中元素的个数<br>spop set1 #随机取set1中的一个元素并将其删除<br>srandmember set2 2 随机取随机个数的函数</p>
<h2 id="5有序集合"><a href="#5有序集合" class="headerlink" title="5有序集合"></a>5有序集合</h2><p>zset<br>zadd paihangbang 100 laowang 550 xiaoming 200 sss 500 qqq #创建一个排行榜集合<br>zrange paihangbang 0 -1#将集合的下标0到-1的元素从小到大排序<br>zrevrange paihangbang 0 -1 同上，不过是从大到小排序</p>
<h2 id="6读写分离配置"><a href="#6读写分离配置" class="headerlink" title="6读写分离配置:"></a>6读写分离配置:</h2><p>主机配置：redis-server –requirepass 设置密码 &gt;redis.log 2 &gt; redis-error.log &amp;<br>从机配置: redis-server –slaveof 主机ip 端口–masterauth 主机设置的密码 &gt; redis.log 2&gt;redis -error.log &amp;<br>redis-cli （进入从机）<br>作为从机连接主机<br>slaveof no one #解除主从配置</p>
<p>history：查看历史命令<br>! 历史命令前的id（如! 997）： 将这个命令在执行一遍</p>
<h2 id="7在python中给mysql查询的文件分页"><a href="#7在python中给mysql查询的文件分页" class="headerlink" title="7在python中给mysql查询的文件分页"></a>7在python中给mysql查询的文件分页</h2><pre><code>import pymysql
from pymysql.cursors import DictCursor

con = pymysql.connect(host=&apos;localhost&apos;, port=3306,
                      database=&apos;hrs&apos;, charset=&apos;utf8&apos;,
                      user=&apos;root&apos;, password=&apos;123456&apos;, autocommit=True)
class Emp():
    def __init__(self,no,name,job,sal):
        self.no=no
        self.name=name
        self.job=job
        self.sal=sal
    def __str__(self):
        return f&apos;{self.no}-{self.name}-{self.job}-{self.sal}&apos;
def main():
    page=int(input(&apos;页码：&apos;))
    size=int(input(&apos;页面大小：&apos;))
    try:
        with con.cursor() as cursor: 元祖形式
            cursor.execute(&apos;select * from tb_emp limit (%s,%s)&apos;,((page-1)*size,size)) #显示从第几页看起，一页显示多少行
            for result in cursor.fetchall():  #返回元祖
                emp=Emp(*result)
                print(emp)
        with con.cursor(DictCursor) as cursor: 字典形式
            cursor.execute(&apos;select * from tb_emp limit (%s,%s)&apos;, ((page - 1) * size, size))
            for result in cursor.fetchall():  #返回字典
                emp=Emp(**result)
                print(emp)

    finally:
        con.close()
</code></pre><h2 id="8随机生成验证码并发送短信（用redis控制一个小时只能发送三次）"><a href="#8随机生成验证码并发送短信（用redis控制一个小时只能发送三次）" class="headerlink" title="8随机生成验证码并发送短信（用redis控制一个小时只能发送三次）"></a>8随机生成验证码并发送短信（用redis控制一个小时只能发送三次）</h2><pre><code>import io
import json
import time
import random
import requests
import redis

def gen_code(length=6):
    &quot;&quot;&quot;生成指定长度的验证码&quot;&quot;&quot;
    result = io.StringIO()
    for _ in range(length):
        result.write(str(random.randint(0, 9)))
    return result.getvalue()

def send_messag_example(tel, code):
   &quot;&quot;&quot;发送短信&quot;&quot;&quot;
    resp = requests.post(
        url=&apos;http://sms-api.luosimao.com/v1/send.json&apos;,
        auth=(&apos;api&apos;, &apos;e67b65751337d36224b26074ceb8a421&apos;),
        data={
            &apos;mobile&apos;: tel,
            &apos;message&apos;: f&apos;您的验证码为{code}。【铁壳测试】&apos;
            # &apos;message&apos;: f&apos;猜猜我是谁。【铁壳测试】&apos;
        },
        timeout=3,
        verify=False
    )
    return json.loads(resp.content)

def my_main():
    tel = input(&apos;请输入手机号:&apos;)
    cli = redis.StrictRedis(host=&apos;112.74.61.160&apos;, port=6379,
                            password=&apos;1qaz2wsx&apos;)
    if not cli.exists(tel):
        result = send_messag_example(tel, gen_code())
        print(result)
        if result[&apos;error&apos;] == 0:
            print(&apos;短信发送成功&apos;)
            cli.set(tel, 1, ex=3600)
    elif int(cli.get(tel)) &lt; 3:
        result = send_messag_example(tel, gen_code())
        print(result)
        if result[&apos;error&apos;] == 0:
            print(&apos;短信发送成功&apos;)
            cli.incr(tel)
    else:
        print(&apos;请不要频繁发送短信验证码（1小时只能发送3次）&apos;)

my_main()
</code></pre><h2 id="9-python中使用redis"><a href="#9-python中使用redis" class="headerlink" title="9 python中使用redis"></a>9 python中使用redis</h2><p>1.连接redis服务器<br>2.创建连接对象<br> cli=redis.StrictRedis(ip,端口,redis登陆密码)</p>
<pre><code>def main():
    cli = redis.StrictRedis(host=&apos;112.74.61.160&apos;, port=6379,
                        password=&apos;1qaz2wsx&apos;)
    try:
        if cli.ping():
            print(&apos;连接成功&apos;)
            print(cli.keys(&apos;*&apos;))
            print(cli.set(&apos;username&apos;, &apos;hellokitty&apos;))
            print(cli.expire(&apos;username&apos;, 120))
            print(cli.get(&apos;username&apos;))
            time.sleep(5)
            print(cli.ttl(&apos;username&apos;))
            cli.sadd(&apos;set1&apos;, &apos;100&apos;, &apos;200&apos;, &apos;100&apos;, &apos;200&apos;, &apos;500&apos;)
            print(cli.scard(&apos;set1&apos;))

    except:
        print(&apos;连接出错&apos;)
    finally:  #可能有错
        cli.shutdown(save=True)
</code></pre><h2 id="10redis和mysql结合提高程序效率示例"><a href="#10redis和mysql结合提高程序效率示例" class="headerlink" title="10redis和mysql结合提高程序效率示例"></a>10redis和mysql结合提高程序效率示例</h2><p>序列化 - 把对象转换成字符或字节序列 - 串行化/腌咸菜<br>反序列化 - 把字符或者字节序列还原成对象 - 反串行化<br>python中要实现对象的序列化和反序列化有三种方案：<br>-json - load/loads / dump/dumps - 字符序列<br>-pickle - load / loads /dump/dumps - 字节序列（使用教多）<br>提高效率原理：redis将数据存放在内存中，mysql存放在硬盘中，从运存中提取数据效率远远高于从硬盘中提取；<br>取数据时，先用redis去内存中查找是否存在数据，如若存在就直接提取，不存在，就利用mysql从数据库提取；<br>最后在利用redis将数据存入内存中，从而方便下次查找，提高效率；<br>可以将常用数据存入redis这样能大大提高效率；<br>例如选择每个省及其下的县市时，省为常用数据，故常将省存在内存中</p>
<pre><code>import pickle
import time
import pymysql
import redis

class District:
&quot;&quot;行政区域&quot;&quot;&quot;
    def __init__(self,distid,name):
        self.distid=distid
        self.name=name
    def __str__(self): #打印函数
        return self.name
    def __repr__(self): # 查看函数
        return self.name

def my_dis():
    # 记录程序执行起始时间
    begin=time.time()
    cli=redis.StrictRedis(host=&apos;120.77.222.217&apos;,
                          port=6379,password=&apos;1qaz2wsx&apos;)
    # 优先从缓存中读取数据，如果缓存没有所需数据，才连接数据库进行查询
    if cli.exists(&apos;provinces&apos;):
        provinces=pickle.loads(cli.get(&apos;provinces&apos;))
        # 直接从缓存中通过键获取数据并反序列化成Python中的对象
    else:
        provinces=[]
        con=pymysql.connect(host=&apos;localhost&apos;, port=3306,
                          database=&apos;hhrs&apos;, charset=&apos;utf8&apos;,
                          user=&apos;root&apos;, password=&apos;123456&apos;)
        try:
            with con.cursor() as cursor:
                # 从数据库中查询省级行政区域
                cursor.execute(&apos;select `distid`,`name` from `tb_district` where `pid` is null&apos;)
                # 将查询结果放入列表容器
                for dist_tuple in cursor.fetchall():
                    # 将元祖数据解包生成对象
                    dist=District(*dist_tuple)
                    # 将对象添到列表
                    provinces.append(dist)
                # 将列表序列化（pickle）然后放入redis中缓存
                cli.set(&apos;provinces&apos;,pickle.dumps(provinces))

        finally:
            con.close()
    # 记录程序执行结束时间
    end=time.time()
    print(f&apos;执行时间：{end-begin}秒&apos;)
    print(provinces)
</code></pre>
      
    </div><!-- .entry-content -->

    <footer class="entry-meta">
    <a href="/2018/12/30/redis数据库主要语法-及与mysql结合用法示例/">
    <time datetime="2018-12-30T11:01:25.000Z" class="entry-date">
        2018-12-30
    </time>
</a>
    
    
    </footer>
</article>






  
    <article id="post-hello-world" class="post-hello-world post type-post status-publish format-standard hentry">
    <!---->

      <header class="entry-header">
        
        
  
    <h1 class="entry-title">
      <a class="article-title" href="/2018/12/20/hello-world/">Hello World</a>
    </h1>
  

        
        <div class="comments-link">
            
            <a href="javascript:void(0);" data-url="http://yoursite.com/2018/12/20/hello-world/" data-id="cjqpf0mah0001msur0thzwf1i" class="leave-reply bdsharebuttonbox" data-cmd="more">分享</a>
        </div><!-- .comments-link -->
      </header><!-- .entry-header -->

    <div class="entry-content">
      
        <p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>

      
    </div><!-- .entry-content -->

    <footer class="entry-meta">
    <a href="/2018/12/20/hello-world/">
    <time datetime="2018-12-20T11:12:25.367Z" class="entry-date">
        2018-12-20
    </time>
</a>
    
    
    </footer>
</article>






  
  

</div></div>
        <div id="secondary" class="widget-area" role="complementary">
  
    <aside id="search" class="widget widget_search"><form role="search" method="get" accept-charset="utf-8" id="searchform" class="searchform" action="//google.com/search">
    <div>
        <input type="text" value="" name="s" id="s">
        <input type="submit" id="searchsubmit" value="搜索">
    </div>
</form></aside>
  
    
  <aside class="widget">
    <h3 class="widget-title">Recents</h3>
    <div class="widget-content">
      <ul>
        
          <li>
            <a href="/2019/01/09/中间件、分页及文件上传/">中间件、分页及文件上传</a>
          </li>
        
          <li>
            <a href="/2019/01/08/cookie及session/">cookie及session</a>
          </li>
        
          <li>
            <a href="/2019/01/07/模板设计/">模板设计</a>
          </li>
        
          <li>
            <a href="/2019/01/04/模型设计/">模型设计</a>
          </li>
        
          <li>
            <a href="/2019/01/03/模型关系映射/">模型关系映射</a>
          </li>
        
      </ul>
    </div>
  </aside>

  
    <aside class="widget">
    <h3 class="widget-title">关于我</h3>
    <div class="widget-content">
      <p>邮箱：huyifi@163.com</p>
      <p>QQ：1838267371</p>
      
    </div>
</aside>
  
    
  <aside class="widget">
    <h3 class="widget-title">Archives</h3>
    <div class="widget-content">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/01/">January 2019</a><span class="archive-list-count">6</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/12/">December 2018</a><span class="archive-list-count">2</span></li></ul>
    </div>
  </aside>

  
    
  
    
  
    
  <aside class="widget">
    <h3 class="widget-title">Music</h3>
    <div class="widget-content">
      <audio src="https://img.hacpai.com/file/2018/11/karera_wo_tame_no_koushinnkyoku-95a27a16.mp3" controls="controls" style="width:100%">
        您的浏览器不支持 audio 标签。
      </audio>
    </div>
  </aside>

  
    <script>
    // sub title
    var subtitleList = [
        "『不懂形式语言就是不懂语言。』——沃·兹基硕德",
        "『涉及到物理实体的项目，必须要仔细论证。』——沃·兹基硕德",
        "『你有无知的权利，也有发表看法的权利，但是没有「无知 && 发表看法」的权利。』——沃·兹基硕德",
        "『韮之大者，高位接盘！』——沃·兹基硕德",
        "『卑鄙是卑鄙者的通行证，高尚是高尚者的墓志铭。』——北岛",
        "『邪人用正法亦邪，正人用邪法亦正。』——谚语",
        "『坦白从宽牢底坐穿，抗拒从严回家过年。』——谚语",
        "『Stay young. Stay simple. Always naive!』——谚语",
        "『3D 打印领域急需一场开源运动。』——沃·兹基硕德",
        "『你们媒体千万要记着，不要「见得风，是得雨」。接到消息，你们媒体本身也要判断。』——长者",
        "『假设这些完全无中生有的东西，你再帮他说一遍，你等于......你也有责任吧？』——长者",
        "『刚才你问我啊，我可以回答你一句「无可奉告」。』——长者",
        "『我告诉你们我是身经百战了，见得多了！』——长者",
        "『美国的华莱士，比你们不知要高到哪里去了，我跟他谈笑风生。』——长者",
        "『我有这个必要告诉你们一点，人生的经验。』——长者",
        "『我没有说要钦定，没有任何这个意思。』——长者",
        "『你们啊，不要想喜欢弄个大新闻，说现在已经钦定了，就把我批判一番。』——长者",
        "『一个人的命运啊，当然要靠自我奋斗，但是也要考虑历史的进程。』——长者",
        "『我说另请高明吧，我实在也不是谦虚。』——长者",
        "『苟利国家生死以，岂因祸福避趋之。』——林则徐《赴戍登程口占示家人二首》",
        "『敢同恶鬼争高下，不向霸王让寸分。』——毛泽东《七律·庆祝第二次核试验成功》",
        "『我生不为逐鹿来，都门懒筑黄金台。状元百官都如狗，总是刀下觳觫材。』——张献忠《七杀诗》",
        "『一泓海水杯中泻，更变千年如走马。』——李贺《梦天》",
    ];
    
    document.addEventListener('DOMContentLoaded', evt => {
        var i = Math.floor(Math.random() * subtitleList.length);
        document.querySelector('#subtitle').innerText = subtitleList[i];
    });

    //Kill XP and IE8
    (function(){
        var ua = navigator.userAgent;
        var res = /Windows NT (\d+\.\d+)/.exec(ua);
        var xpOrLower = res && JSON.parse(res[1]) < 6;
        res = /MSIE (\d+\.\d+)/.exec(ua);
        var ie8OrLower = res && JSON.parse(res[1]) < 9;
        if(xpOrLower || ie8OrLower) {
            alert('请不要用XP及之前的Windows系统，和IE8及之前的IE浏览器访问本站！');
            location.href = "about:blank";
        }
        var fromBaiduSE = /^https?:\/\/www.baidu.com/.test(document.referrer);
        if(fromBaiduSE) {
            alert('检测到你还在使用百度搜索，作为一个程序员，这是一种自暴自弃！\n\n做不作恶的程序员，从不用百度开始！');
            location.href = "about:blank";
        }
    })();
</script>
  
</div>
      </div>
      <footer id="colophon" role="contentinfo">
    <p>&copy; 2019 hyf</p>
    <p>All rights reserved.</p>
    <p>Powered by <a href="http://hexo.io/" target="_blank">Hexo</a></p>
</footer>
    <script>window._bd_share_config={"common":{"bdSnsKey":{},"bdText":"","bdMini":"1","bdMiniList":false,"bdPic":"","bdStyle":"2","bdSize":"16"},"share":{}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];</script>

<script src="/js/jquery-2.0.3.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

<script src="/js/navigation.js"></script>

<div id="bg"></div>

  </div>
</body>
</html>